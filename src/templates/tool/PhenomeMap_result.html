{% set title=tool.name + " Results" %}
{% include 'header.html' %}
{% import 'macros.html' as macros %}



<!-- JSON support for IE (needed to use JS API) -->
<script type="text/javascript" src="../../static/js/cytoscape/json2.min.js"></script>
<!-- Flash embedding utility (needed to embed Cytoscape Web) -->
<script type="text/javascript" src="../../static/js/cytoscape/AC_OETags.min.js"></script>
<!-- Cytoscape Web JS API (needed to reference org.cytoscapeweb.Visualization) -->
<script type="text/javascript" src="../../static/js/cytoscape/cytoscapeweb.min.js"></script>
<!-- Cytoscape settings and graph rendering for tool output -->
<script type="text/javascript" src="../../static/js/cytoscape/PhenomeMap.js"></script>
<script type="text/javascript" src="../../static/d3/d3.min.js"></script>

<div class="page-header">
    <h1>{{ title }}</h1>
</div>

{#
	Checks to see if runhash is defined. If it is, that means we're
	viewing a stored result and PhenomeMap.js won't work properly without
	the extra $.get() call below.
#}
{% if runhash %}
    <script type="text/javascript">

        console.log('wtf');
        var graph_url = '/results/' + '{{async_result.result_image}}';
        var xml = '';
        $.get(graph_url, function (data) {
            xml = data;
            load_cytoscape();
        });

    </script>
{% endif %}


<form id="todo-id" class="form-horizontal" role="form" method="post">
    <div class="row">
        <div class="col-md-12">
            <div class="panel panel-info">
                <div class="panel-heading">
                    <h2 class="panel-title">
                        <a data-toggle="collapse" data-parent="#accordion" href="#jcCollapse">
                            Rerun Tool Options
                        </a>
                    </h2>
                </div>
                <div id="jcCollapse" class="panel-collapse collapse">
                    <div class="panel-body">
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_DisableBootstrap']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_NodeCutoff']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_radio(tool.params['PhenomeMap_Homology']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_GenesInNode']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_UseFDR']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_HideUnEmphasized']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_p-Value']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MinOverlap']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MinGenes']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-5">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_PermutationTimeLimit']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MaxInNode']) }}</div>
                            </div>
                            <div class="col-md-3">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_Permutations']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MaxLevel']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <input type="hidden" name="genesets" value="{{ async_result.gs_ids|join(' ') }}"/>
                            </div>
                            <div class="col-md-4">
                                <button class="btn btn-primary"
                                        type='submit'
                                        value='run'
                                        onclick='this.form.action="{{ url_for('PhenomeMap.run_tool') }}";'>
                                    Run
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</form>

{#
	A fucking hack, since for some reason the tools return SUCCESS even when
	they fail. Checks to see if the results have a key, 'failed', which
	contains the error message for the failure.
#}
{#{% if not async_result.failed %}
<div id="PhenomeMap_cyt" style="position: relative; margin: 10px auto; height: 600px; width: 95%; border-style: solid;">
    <br/>
    <br/>
    Loading Hierarchical Similarity Graph...<br/>
    <br/>
    <br/>
</div>
<!-- js file for heatmap color interpolations -->
 <!-- <script src="http://d3js.org/d3.v3.min.js"></script> -->
<a href="{{ url_for('static_results', filename=async_result.parameters.output_prefix + '.pdf') }}">Export Graph as a PDF</a> |
<a target="_blank" href="{{ url_for('static_results', filename=async_result.parameters.output_prefix + '.svg') }}">Open in Static View</a>

<div id="stats" align="left" style="float: left; margin: 10px">
    <h3>Statistics</h3>
</div>
<div id="shortcuts" align="left" style="float: left; margin: 10px">
    <h3>Shortcuts</h3>
    <table>
        <tr><td><b>Zoom in:</b></td><td>double click background</td></tr>
        <tr><td><b>Zoom out:</b></td><td>shift + double click background</td></tr>
        <tr><td><b>Panning mode:</b></td><td> drag background</td></tr>
    </table>
</div>
{% else %}
	<div class="panel-body bg-red p-15" style="text-align:center">
		<strong>
			No bicliques were found during the analysis. Try running the
			tool again using different parameters.
		</strong>
	</div>
{% endif %}
<script type="text/javascript">
    function loadStats() {
        var result = {{ async_result|tojson }};
        var stats_url = '/results/' + result.parameters.output_prefix + '.el.profile';
        $.get(stats_url, function(data) {
            var lines = data.split('\n');
            lines = lines.slice(Math.max(lines.length - 8, 1), lines.length - 2);
            if(lines.length != 6) {
                $('#stats').append('Not available.');
                return;
            }
            values = [];
            $.each(lines, function(i, v) { values.push(v.split(':')[1].trim()); });
            stats_table = $('<table></table>');
            stats_table.append(
                '<tr><td>Number of genes:</td><td>' + values[0] + '</td></tr>'
                + '<tr><td>Number of genesets:</td><td>' + values[1] + '</td></tr>'
                + '<tr><td>Number of bicliques:</td><td>' + values[3] + '</td></tr>'
                + '<tr><td>Number of edges:</td><td>' + values[2] + '</td></tr>'
                + '<tr><td>Max edge biclique size:</td><td>' + values[4] + '</td></tr>'
                + '<tr><td>Max vertex biclique size:</td><td>' + values[5] + '</td></tr>'
            );
            stats_table.find('td').css('padding', 0);
            $('#stats').append(stats_table);
        });
    }
    // load statistics from file
    $(window).load(loadStats);
</script>#}

<head>
    <meta charset="utf-8">
    <style>

        .node circle {
            cursor: pointer;
            stroke: #3182bd;
            stroke-width: 3px;
            r: 4.5;
        }

        .node text {
            font: 10px sans-serif;
            pointer-events: none;
            text-anchor: middle;
        }

        line.link {
            fill: none;
            stroke: #9ecae1;
            stroke-width: 1.5px;
        }

    </style>

</head>

<div id="viz2">


    <script>
        //Notes:
// Src: http://bl.ocks.org/mbostock/1093130
//Notes:
// * Each dom element is using
//   children to store refs to expanded children
//   _children to store refs to collapsed children
//* It's using both a tree and a graph layout.

//root
//Notes:
// Src: http://bl.ocks.org/mbostock/1093130
//Notes:
// * Each dom element is using
//   children to store refs to expanded children
//   _children to store refs to collapsed children
//* It's using both a tree and a graph layout.

//root
var g = {
    data: null,
    force:null
};

$(function () {

    //use a global var for the data:
    g.data = data;


    var width = 960,
        height = 500;

    var  r = 6,
    	 fill = d3.scale.category20();

    //Create a sized SVG surface within viz:
    var svg = d3.select("#viz2")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

        g.link = svg.selectAll(".link"),
    	g.node = svg.selectAll(".node");



    //Create a graph layout engine:
    g.force = d3.layout.force()
    	.nodes(g.data.nodes)
    	.links(g.data.links)
        .linkDistance(function(link) {
        return ((link.target.depth - link.source.depth)*40);
    	})
        .linkStrength(function(link) {
            return 1/((link.target.depth - link.source.depth)*2);
        })
        .charge(-1200)
    	.chargeDistance(39)
        .gravity(0.0)
        .size([width, height])
    //that invokes the tick method to draw the elements in their new location:
    .on("tick", tick);

/*
    g.link = svg.selectAll("line")
      	.data(g.data.links)
    	.enter().append("svg:line"),

    g.node = svg.selectAll("circle")
      .data(g.data.nodes)
        .enter().append("svg:circle")
      .attr("r", r - .75)
      .style("fill", function(d) { return fill(d.group); })
      .style("stroke", function(d) { return d3.rgb(fill(d.group)).darker(); })
      .call(force.drag);
*/





    //Draw the graph:
    //Note that this method is invoked again
    //when clicking nodes:
    update();


});







//invoked once at the start,
//and again when from 'click' method
//which expands and collapses a node.

function update() {
        var width = 960,
        height = 500;

    //iterate through original nested data, and get one dimension array of nodes.
    var nodes = flatten(g.data.nodes);
	console.log(nodes.length + " nodes to draw");
    for (i = 0; i < nodes.length; i++) {
    	console.log("NODE " + nodes[i].id + ": " + nodes[i].children);
    }
    //Each node extracted above has a children attribute.
    //from them, we can use a tree() layout function in order
    //to build a links selection.
    //var links = g.data.links;
    //console.log(links[0].source);
    var links = getLinks(nodes);
    console.log(links.length + " links to draw");
    for (i = 0; i < links.length; i++) {
    	console.log("LINK " + i + ": " + links[i].source + "\t" + links[i].target);
    }

	g.data.nodes[0].fixed = true;
    g.data.nodes[0].x = width/10;
	g.data.nodes[0].y = height/2;

    // pass both of those sets to the graph layout engine, and restart it
    g.force.nodes(nodes)
        .links(links)
        .start();
	//g.force.linkDistance(
    //-------------------
    // create a subselection, wiring up data, using a function to define
    //how it's suppossed to know what is appended/updated/exited
    g.link = g.link.data(links, function (d) {return d.target.id;});

    //Get rid of old links:
    g.link.exit().remove();

    //Build new links by adding new svg lines:
    g.link
        .enter()
        .insert("line", ".node")
        .attr("class", "link");

    // create a subselection, wiring up data, using a function to define
    //how it's suppossed to know what is appended/updated/exited
    g.node = g.node.data(nodes, function (d) {return d.id;});
    //Get rid of old nodes:
    g.node.exit().remove();
    //-------------------
    //create new nodes by making groupd elements, that contain circls and text:
    var nodeEnter = g.node.enter()
        .append("g")
        .attr("class", "node")
        .on("click", click)
        .call(g.force.drag);
    //circle within the single node group:
    nodeEnter.append("circle")
        .attr("r", function (d) {return Math.sqrt(d.size) / 10 || 4.5;});
    //text within the single node group:
    nodeEnter.append("text")
        .attr("dy", ".35em")
        .text(function (d) {
        return d.name;
    });
    //All nodes, do the following:
    g.node.select("circle")
        .style("fill", color) //calls delegate
        .style("stroke", outerRingColor);
    //-------------------

    g.node.fontcolor(textColor)
}


// Invoked from 'update'.
// The original source data is not the usual nodes + edge list,
// but that's what's needed for the force layout engine.
// So returns a list of all nodes under the root.
function flatten(data) {
    var nodes = [];
    /*
    var node;
    index = 0;
    //count only children (not _children)
    //note that it doesn't count any descendents of collapsed _children
    //rather elegant?
    while (index < nodes.length){
        node = nodes[index];
        //node.id = index;
        console.log("Checking node " + node.id);
        if(node.children.length > 0) {
            for(i = 0; i < node.children.length; i++) {
                nodes.push(data[node.children[i]]);
            }
        }
        //nodes[index].id = index;
        index++;
    }
    */

    function recurse(node) {
        //console.log("recursing through node " + node.id);
        nodes.push(node);
        if(node.children.length>0) {
            //console.log("checking children of node " + node.id + ": " + node.children);
            for (var i=0, count = node.children.length; i < count; i++) {
                //console.log("NODES IN FOR LOOP: " + nodes);
                //console.log("i = " + i + ", count = " + count + ", node " + node.id);
                var nextNode = getNodeByID(data, node.children[i]);
                //if(nextNode.children.length > 0) {
                	//console.log("calling recurse on " + nextNode.name);
                	recurse(nextNode);
                	//console.log("Children array: " + node.children);
                                //console.log("i = " + i + ", count = " + count + ", node " + node.id);

                //}
                //else {
                //    console.log("Node " + nextNode.name + " is a leaf. Pushing...");
                    //nodes.push(nextNode);
                //}

                //console.log("within for loop: came out of recursion for node " + nextNode.name);
            }
        }
        else {
           //console.log(
        }

        //console.log("done recursing through node " + node.name);
        //return nodes;


       //if (next) return next;
    }






    /*
    function recurse(node) {
        nodes.push(node);
        childarr = [];
        for (i = 0, count = node.children.length; i < count; i++) {
         	childarr.push(getNodeByID(data, node.children[i]));
        }
        if (childarr.length > 0) childarr.forEach(recurse);
        //if (!node.id) node.id = ++i;

    }*/
    recurse(data[0]);



    /*
    function recurse(node) {
        if (node.children.length > 0) {
        	for (i = 0; i < node.children.length; i++) {
            	recurse(data[node.children[i]]);
            }
        }
        //if (!node.id) node.id = ++i;
        nodes.push(node);
    }
    recurse(data[0]);
    */

    //Done:
    return nodes;
}



function getNodeByID(nodes, wanted_id) {

    for(var i = 0; i < nodes.length; i++) {
        if(nodes[i].id == wanted_id) {
            return nodes[i];
        }
	}
}


function getLinks(nodes) {

    var links = [];
    for ( var i = 0; i < nodes.length; i++) {
    	var n = nodes[i];
        for (var j = 0; j < n.children.length; j++) {
            var link = {
        		source:nodes.indexOf(n),
        		target:nodes.indexOf(getNodeByID(nodes, n.children[j]))
    		};
            //console.log("node: " + n.id + "\n\tchildren: " + n.children[j]);
            //console.log(link.source + "\t" + link.target);
            links.push(link);
        }
    }

    return links;
}

/*
// Invoked from 'update'.
// The original source data is not the usual nodes + edge list,
// but that's what's needed for the force layout engine.
// So returns a list of all nodes under the root.
function children(node) {
    var children = [],
        id = 0,
    	i = 0;
    var nodes = g.data.nodes
    var links = g.data.links

    for(n in nodes) {
        if (n.name.equals(node.name)) {
        	id = i;
            break;
        }
        i++;
	}

    i = 0;
    for (link in links)
    {
        if (link.source == id) {


    function recurse(node) {
        if (node.children) node.children.forEach(recurse);
        if (!node.id) node.id = ++i;
        nodes.push(node);
    }
    recurse(data);

    //Done:
    return nodes;
}
*/


//BEN'S COMMENTS
//This is the color function I was having problems with. I think the fact that all the nodes are black is symptomatic of the nodes not properly recognizing if they have children.



//Invoked from 'update'
//Return the color of the node
//based on the children value of the
//source data item: {name=..., children: {...}}
function color(d) {
/*
    var color = "3100bd";

    if(d._children)
    	color = "#3182bd";
    else if(d.children == [])
        //alert("empty children");
        color = "#c6dbef";
    else
        color = "fd8d3c";
*/
    return d._children ? "#3182bd" // collapsed package
    :
    d.children.length > 0 ? "#c6dbef" // expanded package
    :
        "#fd8d3c"; // leaf node

//   return color;
}


function outerRingColor(d) {
    if (d.emphasis){
        return "#33AD33";
    }
    else return "default";
}

function textColor(d) {
    if (d.emphasis){
        return "#CC0000";
    }
    else return "default";
}


// Toggle children on click by switching around values on _children and children.
function click(d) {
    if (d3.event.defaultPrevented) return; // ignore drag
    if (d.children.length > 0) {
        console.log("collapsing node " + d.name + " (" + d.id + ")");
        d._children = d.children;
        d.children = [];
        console.log(d.children);
        console.log(d._children);
    } else {
        console.log("expanding node " + d.name + " (" + d.id + ")");
        d.children = d._children;
        d._children = null;
        console.log(d.children);
        console.log(d._children);
    }
    //
    update();
}

//event handler for every time the force layout engine
//says to redraw everthing:
function tick() {
    g.node.attr("transform", function (d) {
        return "translate(" + Math.max(d.depth*100 + 50, d.x) + "," + d.y + ")";
    });
    //redraw position of every link within the link set:


    //same for the nodes, using a functor:

    g.link.attr("x1", function (d) {
        return (Math.max(d.source.depth*100 + 50, d.source.x));
    })
        .attr("y1", function (d) {
        return d.source.y;
    })
        .attr("x2", function (d) {
        return (Math.max(d.target.depth*100 + 50, d.target.x));
    })
        .attr("y2", function (d) {
        return d.target.y;
    });
    //same for the nodes, using a functor:


}

var data =
{
    "nodes": [
                {"id": 0, "name": "flare", "children": [1], "depth": 0, "emphasis": true},                  //0
                {"id": 1, "name": "analytics", "children": [2, 7, 13, 15], "depth": 1},              //1
                {"id": 2, "name": "cluster", "children": [3, 4, 5, 6], "depth": 2},                //2
                {"id": 3, "name": "AgglomerativeCluster","children": [], "depth": 3},   //3
                {"id": 4, "name": "CommunityStructure", "children": [], "depth": 3},     //4
                {"id": 5, "name": "HierarchicalCluster", "children": [], "depth": 3},    //5
                {"id": 6, "name": "MergeEdge", "children": [], "depth": 3},              //6
                {"id": 7, "name": "graph", "children": [8, 9, 10, 11, 12], "depth": 2},                  //7
                {"id": 8, "name": "BetweennessCentrality", "children": [], "depth": 3},  //8
                {"id": 9, "name": "LinkDIstance", "children": [], "depth": 3},           //9
                {"id": 10, "name": "MaxFlowMinCut", "children": [], "depth": 3},          //10
                {"id": 11, "name": "ShortestPaths", "children": [], "depth": 3},          //11
                {"id": 12, "name": "SpanningTree", "children": [], "depth": 3},           //12
                {"id": 13, "name": "optimization", "children": [14], "depth": 2},           //13
                {"id": 14, "name": "AspectRatioBanker", "children": [], "depth": 3},       //14
        		{"id": 15, "name": "TestLeaf", "children": [], "depth": 3, "emphasis":true}       //14
            ],


    "links": [
                {"source": 0, "target": 1},
                {"source": 1, "target": 2},
                {"source": 1, "target": 7},
                {"source": 1, "target": 13},
                {"source": 2, "target": 3},
                {"source": 2, "target": 4},
                {"source": 2, "target": 5},
                {"source": 2, "target": 6},
                {"source": 7, "target": 8},
                {"source": 7, "target": 9},
                {"source": 7, "target": 10},
                {"source": 7, "target": 11},
                {"source": 7, "target": 12},
                {"source": 13, "target": 14}
            ]
};
</script>


</div>
