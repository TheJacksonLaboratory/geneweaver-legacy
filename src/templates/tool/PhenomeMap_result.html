{% set title=tool.name + " Results" %}
{% include 'header.html' %}
{% import 'macros.html' as macros %}
<head xmlns="http://www.w3.org/1999/html">
    <meta charset="utf-8">
    <style>

        .node circle {
            cursor: pointer;
            stroke: #3182bd;
            stroke-width: 3px;
        }

        .found {
            fill: #ff4136;
            stroke: #ff4136;
        }

        .node text {
            font: 12px sans-serif;
            pointer-events: none;
            text-shadow:
                -1px -1px 0 #FFF,
                1px -1px 0 #FFF,
                -1px 1px 0 #FFF,
                1px 1px 0 #FFF;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        /*Just making sure the select2 box is glued to the top*/
        .search {
            width: 100%;
        }

        .legend {
                height: 100px;
                width: 100px;
	            padding: 5px;
	            font: 10px sans-serif;
	            background: yellow;
	            box-shadow: 2px 2px 1px #888;
            }

    </style>

</head>
{#
<!-- JSON support for IE (needed to use JS API) -->
<script type="text/javascript" src="../../static/js/cytoscape/json2.min.js"></script>
<!-- Flash embedding utility (needed to embed Cytoscape Web) -->
<script type="text/javascript" src="../../static/js/cytoscape/AC_OETags.min.js"></script>
<!-- Cytoscape Web JS API (needed to reference org.cytoscapeweb.Visualization) -->
<script type="text/javascript" src="../../static/js/cytoscape/cytoscapeweb.min.js"></script>
<!-- Cytoscape settings and graph rendering for tool output -->
<script type="text/javascript" src="../../static/js/cytoscape/PhenomeMap.js"></script>
#}
<link rel="stylesheet" type="text/css" href="../../static/select2/select2.min.css"> </link>
<script type="text/javascript" src="../../static/d3/d3.min.js"></script>
<script type="text/javascript" src="../../static/select2/select2.min.js"></script>

{#<script type="text/javascript" src="../../static/d3/HiSimGraph.js"> </script>#}
{{ data | safe }}
{#<script>#}
{#    var d = {{  data |safe }};#}
{#    console.log(d.nodes[0].id);#}
{#</script>#}

<div class="page-header">
    <h1>{{ title }}
        {{ runhash }} </h1>
</div>

{# {{ async_result.parameters.output_prefix}} #}

{#
	Checks to see if runhash is defined. If it is, that means we're
	viewing a stored result and PhenomeMap.js won't work properly without
	the extra $.get() call below.
#}


{% if runhash %}
    <script type="text/javascript">

        console.log('wtf');

        var graph_url = '/results/' + '{{async_result.result_image}}';
        var xml = '';
        $.get(graph_url, function (data) {
            xml = data;
            load_cytoscape();
        });

    </script>
{% endif %}


<form id="todo-id" class="form-horizontal" role="form" method="post">
    <div class="row">
        <div class="col-md-12">
            <div class="panel panel-info">
                <div class="panel-heading">
                    <h2 class="panel-title">
                        <a data-toggle="collapse" data-parent="#accordion" href="#jcCollapse">
                            Rerun Tool Options
                        </a>
                    </h2>
                </div>
                <div id="jcCollapse" class="panel-collapse collapse">
                    <div class="panel-body">
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_DisableBootstrap']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_NodeCutoff']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_radio(tool.params['PhenomeMap_Homology']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_GenesInNode']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_UseFDR']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_HideUnEmphasized']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_p-Value']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MinOverlap']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MinGenes']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-5">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_PermutationTimeLimit']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MaxInNode']) }}</div>
                            </div>
                            <div class="col-md-3">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_Permutations']) }}</div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">{{ macros.tool_param_select(tool.params['PhenomeMap_MaxLevel']) }}</div>
                            </div>
                            <div class="col-md-4">
                                <input type="hidden" name="genesets" value="{{ async_result.gs_ids|join(' ') }}"/>
                            </div>
                            <div class="col-md-4">
                                <button class="btn btn-primary"
                                        type='submit'
                                        value='run'
                                        onclick='this.form.action="{{ url_for('PhenomeMap.run_tool') }}";'>
                                    Run
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</form>

{#
	A hack, since for some reason the tools return SUCCESS even when
	they fail. Checks to see if the results have a key, 'failed', which
	contains the error message for the failure.
#}
{# {% if not async_result.failed %}
<div id="PhenomeMap_cyt" style="position: relative; margin: 10px auto; height: 600px; width: 95%; border-style: solid;">
    <br/>
    <br/>
    Loading Hierarchical Similarity Graph...<br/>
    <br/>
    <br/>
</div>
<!-- js file for heatmap color interpolations -->
 <!-- <script src="http://d3js.org/d3.v3.min.js"></script> -->
<a href="{{ url_for('static_results', filename=async_result.parameters.output_prefix + '.pdf') }}">Export Graph as a PDF</a> |
<a target="_blank" href="{{ url_for('static_results', filename=async_result.parameters.output_prefix + '.svg') }}">Open in Static View</a>

<div id="stats" align="left" style="float: left; margin: 10px">
    <h3>Statistics</h3>
</div>
<div id="shortcuts" align="left" style="float: left; margin: 10px">
    <h3>Shortcuts</h3>
    <table>
        <tr><td><b>Zoom in:</b></td><td>double click background</td></tr>
        <tr><td><b>Zoom out:</b></td><td>shift + double click background</td></tr>
        <tr><td><b>Panning mode:</b></td><td> drag background</td></tr>
    </table>
</div>
{% else %}
	<div class="panel-body bg-red p-15" style="text-align:center">
		<strong>
			No bicliques were found during the analysis. Try running the
			tool again using different parameters.
		</strong>
	</div>
{% endif %}
<script type="text/javascript">
    function loadStats() {
        var result = {{ async_result|tojson }};
        var stats_url = '/results/' + result.parameters.output_prefix + '.el.profile';
        $.get(stats_url, function(data) {
            var lines = data.split('\n');
            lines = lines.slice(Math.max(lines.length - 8, 1), lines.length - 2);
            if(lines.length != 6) {
                $('#stats').append('Not available.');
                return;
            }
            values = [];
            $.each(lines, function(i, v) { values.push(v.split(':')[1].trim()); });
            stats_table = $('<table></table>');
            stats_table.append(
                '<tr><td>Number of genes:</td><td>' + values[0] + '</td></tr>'
                + '<tr><td>Number of genesets:</td><td>' + values[1] + '</td></tr>'
                + '<tr><td>Number of bicliques:</td><td>' + values[3] + '</td></tr>'
                + '<tr><td>Number of edges:</td><td>' + values[2] + '</td></tr>'
                + '<tr><td>Max edge biclique size:</td><td>' + values[4] + '</td></tr>'
                + '<tr><td>Max vertex biclique size:</td><td>' + values[5] + '</td></tr>'
            );
            stats_table.find('td').css('padding', 0);
            $('#stats').append(stats_table);
        });
    }
    // load statistics from file
    $(window).load(loadStats);
</script>
#}

<div id="search"></div>

<div id="viz2">
    <script>
        //Notes:
//
// Initially borrowed from http://bl.ocks.org/mbostock/1093130
//      with heavy modification. Creates a DAG and displays it in a tree
//      shaped manner, where each child node can have multiple parents, and each
//      non-leaf is collapsible.
//Notes:
// * Each dom element is using
//   children to store refs to expanded children
//   _children to store refs to collapsed children


        //root
        var g = {
            data: null,
            force: null
        };

        g.data = {{ data | safe }};

        var dictionary = {};

        var colors_g = ["#3366cc", "#dc3912", "#ff9900", "#109618", "#990099", "#0099c6", "#dd4477",
            "#66aa00", "#b82e2e", "#316395", "#994499", "#22aa99", "#aaaa11", "#6633cc", "#e67300",
            "#8b0707", "#651067", "#329262", "#5574a6", "#3b3eac"];

        //initialization
        $(function () {

            //console.log("DATA = " + JSON.stringify(data));
            var width = 1200,
                    height = 1000,
                    select2_data;

            var r = 6,
                    fill = d3.scale.category20();


            //Create a sized SVG surface within viz:
            var svg = d3.select("#viz2")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

            var legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("height", 100)
                    .attr("width", 100)
                    .attr("transform", "translate(900)");

            legend.selectAll('rect')
                    .data(dictionary)
                    .enter()
                    .append("rect")
                    .attr("x", function (d, i) {
                        return i * 20;
                    })
                    .attr("y", height + 20)
                    .attr("width", 10)
                    .attr("height", 10)
                    .style("fill", function (d, i) {
                        var color = colors_g[dictionary[i]];
                        return color;
                    });

            legend.selectAll('text')
                    .data(dictionary)
                    .enter()
                    .append("text")
                    .attr("x", function (d, i) {
                        return i * 20 + 9;
                    })
                    .attr("y", ((height + 20) * -1))
                    .text(function (d, i) {
                        var text = dictionary[i];
                        return text;
                    });

            g.link = svg.selectAll("path.link"),
                    g.node = svg.selectAll(".node");


            //Create a graph layout engine:
            g.force = d3.layout.force()
                    .nodes(g.data.nodes)
                    .links(getLinks(g.data.nodes))
                //linkDistance proportional to difference in depths to prevent crowding
                    .linkDistance(function (link) {
                        return ((link.target.depth - link.source.depth) * 40);
                    })
                //linkStrength also proportional to distance
                    .linkStrength(function (link) {
                        return 1 / ((link.target.depth - link.source.depth) * 1.5);
                    })
                //Deeper nodes have a stronger charge because there's more jostling for space down there
                    .charge(function (d) {
                        return (-((d.depth + 1) * 400));
                    })
                    .chargeDistance(300)
                    .gravity(0.05)
                    .size([width, height])
                    .on("tick", tick);


            //Initialize positions of tree elements to reduce tangling caused by random initialization
            var nodes = flatten(g.data.nodes);
            initialize_layout(nodes);

            select2_data = extract_select2_data();

            console.log(select2_data);


            $("#search").select2({
                data: select2_data,
                containerCssClass: "search"
            });


            //Draw the graph:
            //Note that this method is invoked again
            //when clicking nodes:
            update();


});


//invoked once at the start,
//and again when from 'click' method
//which expands and collapses a node.

function update() {
    var width = 960,
        height = 500,
        padding = 15;

    //iterate through original nested data, and get one dimension array of nodes.
    var nodes = flatten(g.data.nodes);
    for(var i = 0; i < nodes.length; i++){
        console.log("Node " + nodes[i].id + "\n\tAbove: " + nodes[i].above +
                    "\n\tBelow: " + nodes[i].below);
    }
    //console.log(nodes.length + " nodes to draw");


    //Each node extracted above has a children attribute.
    //from them, we can use a tree() layout function in order
    //to build a links selection.

    var links = getLinks(nodes);


    // pass both of those sets to the graph layout engine, and restart it
    g.force.nodes(nodes)
        .links(links)
        .start();
    //-------------------
    // create a subselection, wiring up data, using a function to define
    //how it's supposed to know what is appended/updated/exited
    g.link = g.link.data(links);

            //Build new links by adding new svg lines:
            g.link
                    .enter()
                    .insert("line", ".node")
                    .attr("class", "link");


            /*g.link
             .enter()
             .insert("path", "g")
             .attr("class", "link")
             .attr("d", function(d) {
             console.log(d);
             var o = {x: d.source.x, y: d.source.y};
             return diagonal({source: o, target: o});
             });*/

            // create a subselection, wiring up data, using a function to define
            //how it's suppossed to know what is appended/updated/exited
            g.node = g.node.data(nodes, function (d) {
                return d.id;
            });
            //Get rid of old nodes:
            g.node.exit().remove();
            //-------------------
            //create new nodes by making groupd elements, that contain circls and text:
            var nodeEnter = g.node.enter()
                    .append("g")
                    .attr("class", "node")
                    .on("click", click)
                    .on("mouseover", mouseover)
                    .on("mouseout", mouseout)
                    .call(g.force.drag);
            //circle within the single node group:
            nodeEnter.append("circle")
                    .attr("r", 4.5);
    
    g.link.style("stroke", function(d) {
       if(d.source.found && d.target.found) {
           return "red";
       }
        else{
           return "#ccc";
       }
    });

            //text within the single node group:
            nodeEnter.append("text")
                    .attr("dy", "-.2em")
                    .attr("dx", function (d) {
                        return (d.children.length > 0) ? "-1em" : "1em";
                    })
                    .attr("text-anchor", function (d) {
                        return (d.children.length > 0) ? "end" : "start";
                    })
                    .text(function (d) {
            return d.Genesets.length <= 3 ? d.Genesets : d.Genesets.length + " sets..." ;
            //return d.Genesets;
        });
            nodeEnter.append("text")
                    .attr("dy", "1em")
                    .attr("dx", function (d) {
                        return (d.children.length > 0) ? "-1em" : "1em";
                    })
                    .attr("text-anchor", function (d) {
                        return (d.children.length > 0) ? "end" : "start";
                    })
                    .text(function (d) {
            return d.Genes.length <= 3 ? d.Genes : d.Genes.length + " genes..." ;
            //return d.Genes;
        });

            //All nodes, do the following:
            g.node.select("circle")
                    .style("fill", function(d) { return colors_google(d); } )
                    .style("stroke", function(d) { return colors_google(d); })
                    .style("fill-opacity", opacity);
            //-------------------

            //g.node.fontcolor(textColor)
            g.node.select("text").attr("fill", textColor);
    
    //console.log(g.force.nodes());
    g.force.start();
    var circles = d3.selectAll("circle");
    circles.attr("r", function(d) {
        return(d.weight >=3 ? 4.5*Math.sqrt(d.weight) : 4.5);
    });

        }

        function colors_google(d) {
            console.log("Species: " + d.species + "Species Length:" + d.species.length);

            if(d.species.length > 1){
                return "#636363";
            }

            else if (!(d.species in dictionary)) {
                dictionary[d.species] = Object.keys(dictionary).length;
            }

            return colors_g[dictionary[d.species]];
        }
        
                //Invoked from 'update'
        //Return the color of the node
        //based on the children value of the
        //source data item: {name=..., children: {...}}
        function opacity(d) {
            return d._children ? "1" // collapsed package
                    :
                    d.children.length > 0 ? ".55" // expanded package
                            :
                            "0"; // leaf node
        }

        //Changes text color for emphasis
        function textColor(d) {
            if (d.emphasis) {
                return '#CC0000';
            }
            else return 'default';
        }
        
        function mouseover(d) {
            d3.select(this).append("text")
                    .attr("class", "hover")
                    .attr('transform', function (d) {
                        return 'translate(5, -5)';
                    })
                    .attr("dx", function (d) {
                        return (d.children.length > 0) ? "1em" : "-1em";
                    })
                    .attr("text-anchor", function (d) {
                        return (d.children.length > 0) ? "start" : "end";
                    })
                    .text(d.Genesets + ": " + d.species)
                    .style("font-weight", "bold");
        }

        function mouseout(d) {
            d3.select(this).select("text.hover").remove();
        }
        

        // Invoked from 'update'.
// The original source data is not the usual nodes + edge list,
// but rather an adjacency list of nodes and their children.
// We need a list of nodes + links for the force layout engine.
// So returns a list of all nodes under the root.
function flatten(data) {
    var nodes = [];
    //checks to see which nodes have no parents. these are the only nodes we will recurse on,
    //to make sure we cover the entire tree with minimum redundancy. Worth a O(n) operation once
    //to save up to n extra recursive calls, and prevents collapsed children from showing up when they
    //shouldn't
    for (var i = 0, len = data.length; i < len; i++) {
        data[i].orphan = true;
    }
    for (var i = 0, len = data.length; i < len; i++) {
        if (data[i]._children) {
            for(var j = 0, jlen = data[i]._children.length; j < jlen; j++){
                //console.log("PARAM 1: " + data + "\n PARAM 2: " + data[i]._children[j]);
                getNodeByID(data, data[i]._children[j]).orphan = false;
            }
        }
        else {
             for(var j = 0, jlen = data[i].children.length; j < jlen; j++){
                 getNodeByID(data, data[i].children[j]).orphan = false;
             }
        }
    }

//recursively get each node's children and it's children's children. does not
    //look at collapsed children or their children.
    function recurse(node) {
        if (!getNodeByID(nodes, node.id)) {
            nodes.push(node);
        }
        if (node.children.length > 0) {
            for (var i = 0, count = node.children.length; i < count; i++) {
                var nextNode = getNodeByID(data, node.children[i]);
                recurse(nextNode);
            }
        }
    }

    //recurse on orphans only
    for (var i = 0, len = data.length; i < len; i++) {
        if (data[i].orphan) {
            recurse(data[i]);
        }
    }
    return nodes;
}

//nodes are identified in the children arrays by their ID, so we need
//this function to access the nodes.
function getNodeByID(nodes, wanted_id) {
    for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].id == wanted_id) {
            return nodes[i];
        }
    }
}

//gets the array of link objects for the force diagram to use
function getLinks(nodes) {

    var links = [];
    for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        for (var j = 0; j < n.children.length; j++) {
            var link = {
                source: n,
                target: getNodeByID(nodes, n.children[j])
            };
            if (link.source.found && link.target.found) {
                link.class = "found";
            }
            links.push(link);
        }
    }

    return links;
}

function initialize_layout(nodes) {
    var nextdepths = [0];
    var previous = [-1];
    for (i = 0; i < nodes.length; i++) {
        while (nodes[i].depth > nextdepths.length - 1) {
            nextdepths.push(0);
            previous.push(-1);
        }
        if(previous[nodes[i].depth] >= 0) {
            prevNode = getNodeByID(nodes, previous[nodes[i].depth]);
            prevNode.below = nodes[i].id;
            nodes[i].above = prevNode.id;
        }
        previous[nodes[i].depth] = nodes[i].id;
        nodes[i].x = nodes[i].depth * 100 + 100;
        nodes[i].y = nextdepths[nodes[i].depth] * 20 + 100;
        nextdepths[nodes[i].depth]++;
    }
}

//Collapses nodes upon click, unless they're being dragged.
//essentially switches the "active" children array with the
// "hidden" _children array.
function click(d) {
    if (d3.event.defaultPrevented) return; // ignore drag
    if (d.children.length > 0) {
        //console.log("collapsing node " + d.Genesets + " (" + d.id + ")");
        d._children = d.children;
        d.children = [];
        //console.log("children: " + d.children);
        //console.log("_children:" + d._children);
    } else if (d._children) {
        //console.log("expanding node " + d.Genesets + " (" + d.id + ")");
        d.children = d._children;
        d._children = null;
        //console.log("children: " + d.children);
        //console.log("_children:" + d._children);
    }
    nodes = flatten(g.data.nodes);
    initialize_layout(nodes);
    //
    update();
}


//NOT YET IN USE--SEARCH FUNCTIONALITY
//basically a way to get the path to an object
function searchTree(search) {
    console.log("SEARCH STRING : " + search);
    path = [];
    for(var i = 0; i < g.data.nodes.length; i++) {
        g.data.nodes[i].found = false;
        if(g.data.nodes[i].Genesets.indexOf(search) >= 0) {
            path.push(g.data.nodes[i]);
        }
    }
    return path;
}

//NOT YET IN USE--SEARCH FUNCTIONALITY
function extract_select2_data() {
    var index = 0;
    var data = g.data.nodes;
    var leaves = [];
    var leaf = data[0];
    while(leaf.children.length > 0) {
        leaf = getNodeByID(data, leaf.children[0]);
    }
    var leafdepth = leaf.depth;
    for(var i = 0; i < data.length; i++) {
        if (data[i].depth == leafdepth) {
            leaves.push({"id":++index,"text":data[i].Genesets[0]});
        }
    }
    return leaves;
}

//NOT YET IN USE--SEARCH FUNCTIONALITY
function openPaths(paths) {
    for (var i = 0; i < paths.length; i++) {
        //if (!paths[i].orphan) {//i.e. not root
            paths[i].found = true;
            if (paths[i]._children) { //if children are hidden: open them, otherwise: don't do anything
                paths[i].children = paths[i]._children;
                paths[i]._children = null;
        }
    }
    update();
}

//NOT YET IN USE--SEARCH FUNCTIONALITY
$("#search").on("select2-selecting", function (e) {
    var roots = [];
    var paths = [];

    paths = searchTree(e.object.text);
    console.log(paths);
    if (typeof(paths) !== "undefined") {
        openPaths(paths);
    }
    else {
        alert(e.object.text + " not found!");
    }
})


//event handler for every time the force layout engine
//says to redraw everything: keeps each node in its respective column
function tick() {

    //for (var i = 0; i < g.force.nodes().length; i++) {
        //console.log("COLLIDING NODE " + g.force.nodes()[i].id);
     	//collide(g.force.nodes()[i]);
    //}

    g.node.attr("transform", function (d) {
        //collide(d);
        d.x = d.depth * 200 + 100;
        return ("translate(" + d.x + "," + d.y + ")");
    });
    //redraw position of every link within the link set:

    g.link.attr("x1", function (d) {
        return d.source.x;
    })
        .attr("y1", function (d) {
            return d.source.y;
        })
        .attr("x2", function (d) {
            return d.target.x;
        })
        .attr("y2", function (d) {
            return d.target.y;
        });
}

/*function collide(node) {
    //node.py = node.y;
    //console.log("colliding");
	var pad = 15*Math.pow(node.depth, .3),
        ny1 = node.y - pad,
        ny2 = node.y + pad;
        if(typeof node.above !== 'undefined') {
            //console.log("collision between " + node.id + " and " + node.above);
        	var above = getNodeByID(g.force.nodes(), node.above);
            //above.py = above.y;
            var dy = node.y - above.y;
            var l = Math.abs(dy);
            pad *=2
            if(l < pad) {
                l  = (l-pad) / l * .05;
                node.y -= dy *=l;
                above.y += dy;
        	}
            if(above.y > node.y) {
             	node.above = above.above;
                above.below = node.below;
                node.below = above.id;
                above.above = node.id;
            }
    	}
        if(typeof node.below !== 'undefined') {
            //console.log("PARAM 1: " + g.force.nodes() + "\n PARAM 2: " + node.below);
        	var below = getNodeByID(g.force.nodes(), node.below);
            //below.py = below.y;
            //console.log("collision between " + node.id + " and " + node.above);
            var dy = node.y - below.y;
            var l = Math.abs(dy);
            pad*=2
            if(l < pad) {
                l  = (l-pad) / l * .05;
                console.log("L = " + l);
                node.y -= dy *=l;
                below.y += dy;
        	}
            if(below.y < node.y) {
             	node.below = below.below;
                below.above = node.above;
                node.above = below.id;
                below.below = node.id;
            }
    	}
}*/


//sample data. we can load it from a separate file and make it work, but we're
//choosing not to for the beta demonstration, in case that causes a hiccup on a different machine.
//
/*var data = {
    "nodes": [
        {"id": 0, "Genesets": ["One", "Two", "Three", "Four", "Five"], "Genes": ["I"], "children": [1, 2], "depth": 0},
        {"id": 1, "Genesets": ["One", "Two", "Four", "Five"], "Genes": ["A", "I"], "children": [3, 16], "depth": 1},
        {"id": 2, "Genesets": ["Two", "Three", "Four", "Five"], "Genes": ["I", "K"], "children": [6, 16], "depth": 1},
        {"id": 3, "Genesets": ["One", "Two", "Four"], "Genes": ["A", "E", "I"], "children": [7,8], "depth": 2},
        {"id": 4, "Genesets": ["One", "Two", "Three"], "Genes": ["G","I"], "children": [9,10], "depth": 2},
        {"id": 5, "Genesets": ["One", "Three", "Four"], "Genes": ["I","J"], "children": [7, 11], "depth": 2},
        {"id": 6, "Genesets": ["Two", "Three", "Four"], "Genes": ["I", "K", "M"], "children": [9, 11], "depth": 2, "emphasis": true},
        {"id": 7, "Genesets": ["One", "Four"], "Genes": ["A", "E", "I", "B", "D", "J"], "children": [12, 15], "depth": 3},
        {"id": 8, "Genesets": ["One", "Two"], "Genes": ["A", "C", "E", "G", "I"], "children": [12, 13], "depth": 3},
        {"id": 9, "Genesets": ["Two", "Three"], "Genes": ["G", "I", "M", "P"], "children": [13, 14], "depth": 3, "emphasis": true},
        {"id": 10, "Genesets": ["One", "Three"], "Genes": ["G", "H", "I", "J"], "children": [12, 14], "depth": 3},
        {"id": 11, "Genesets": ["Three", "Four"], "Genes": ["I", "J", "K", "L", "M", "N"], "children": [14, 15], "depth": 3, "emphasis": true},
        {"id": 12, "Genesets": ["One"], "Genes": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"], "children": [], "depth": 4},
        {"id": 13, "Genesets": ["Two"], "Genes": ["A", "C", "E", "G", "I", "K", "M", "P"], "children": [], "depth": 4, "emphasis": true},
        {"id": 14, "Genesets": ["Three"], "Genes": ["G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T"], "children": [], "depth": 4, "emphasis": true},
        {"id": 15, "Genesets": ["Four"], "Genes": ["A", "B", "D", "E", "I", "J", "K", "L", "M", "N"], "children": [], "depth": 4, "emphasis": true},
        {"id": 16, "Genesets": ["Five"], "Genes": ["A", "I", "K"], "children": [], "depth": 4}



        
        {"id": 16, "Genesets": "EXTRA1", "children": [1, 4, 7], "depth": 0},              //1
        {"id": 17, "Genesets": "EXTRA2", "children": [1, 2, 15], "depth": 0},              //1
        {"id": 18, "Genesets": "EXTRA3", "children": [2, 15, 14], "depth": 0},              //1
        {"id": 19, "Genesets": "EXTRA4", "children": [7, 13, 22], "depth": 1},              //1
        {"id": 20, "Genesets": "EXTRA5", "children": [22, 23], "depth": 1},              //1
        {"id": 21, "Genesets": "EXTRA6", "children": [12], "depth": 1},              //1
        {"id": 22, "Genesets": "EXTRA7", "children": [3, 4, 5, 12, 14, 15], "depth": 2},              //1
        {"id": 23, "Genesets": "EXTRA8", "children": [14], "depth": 2},              //1

        {"id": 0, "Genesets": "flare", "children": [1, 22], "depth": 0, "emphasis": true},                  //0
        {"id": 1, "Genesets": "analytics", "children": [2, 7, 13], "depth": 1},              //1
        {"id": 2, "Genesets": "cluster", "children": [3, 4, 5, 6, 15], "depth": 2},                //2
        {"id": 3, "Genesets": "AgglomerativeCluster", "children": [], "depth": 3},   //3
        {"id": 4, "Genesets": "CommunityStructure", "children": [], "depth": 3},     //4
        {"id": 5, "Genesets": "HierarchicalCluster", "children": [], "depth": 3},    //5
        {"id": 6, "Genesets": "MergeEdge", "children": [], "depth": 3},              //6
        {"id": 7, "Genesets": "graph", "children": [8, 9, 10, 11, 12, 15], "depth": 2},                  //7
        {"id": 8, "Genesets": "BetweennessCentrality", "children": [], "depth": 3},  //8
        {"id": 9, "Genesets": "LinkDIstance", "children": [], "depth": 3},           //9
        {"id": 10, "Genesets": "MaxFlowMinCut", "children": [], "depth": 3},          //10
        {"id": 11, "Genesets": "ShortestPaths", "children": [], "depth": 3},          //11
        {"id": 12, "Genesets": "SpanningTree", "children": [], "depth": 3},           //12
        {"id": 13, "Genesets": "optimization", "children": [14, 15], "depth": 2},           //13
        {"id": 14, "Genesets": "AspectRatioBanker", "children": [], "depth": 3},       //14
        {"id": 15, "Genesets": "TestLeaf", "children": [], "depth": 3, "emphasis": true}       //14
        
    ]
};
*/
    </script>

</div>
