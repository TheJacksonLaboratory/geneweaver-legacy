{% set title=tool.name + " Results" %}
{% include 'header.html' %}
{% import 'macros.html' as macros %}

<style>


  .nav-justified > li {
    display: table-cell;

    max-width: 10ch;
    width: 1%;
    padding-right: 1px;
  }
  .nav-justified > li > a  {
    border-bottom: 1px solid #ddd !important;
    border-radius: 4px 4px 0 0 !important;
    margin-bottom: 0 !important;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .nav-tabs.nav-justified > .active > a,
  .nav-tabs.nav-justified > .active > a:hover,
  .nav-tabs.nav-justified > .active > a:focus {
    border-bottom-color: #fff !important;
  }


  .result-search-input{
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    width: 100%;
  }

  .progress {
      position: relative;
  }

  .progress span {
      position: absolute;
      display: block;
      width: 100%;
      color: white;

   }
  .title-col{
      margin-bottom: 10px;
  }

  .extra-info-header{
      margin-top: 0;
  }

  .nav.nav-tabs>li>a{
    background-color: #006400;
    color: #EEEEEE;
  }

  .table-col{
      padding-left: 0;
  }

  .table-list-search th {
    position: relative;
    cursor: pointer;
    text-transform: none;
    padding-left: 10px;
  }

  .table-list-search th.desc:after {
    border-top-color: #666;
  }

  .table-list-search th.asc:before {
    border-bottom-color: #666;
  }

  .table-list-search th:after, .table-list-search th:before {
    content: '';
    display: block;
    position: absolute;
    right: 0;
    border-color: transparent;
    border-style: solid;
    border-width: 5px;
    width: 0;
    height: 0;
  }

  .table-list-search th:after {
    border-top-color: #ddd;
    top: 20px;
  }

  .table-list-search th:before {
    border-bottom-color: #ddd;
    top: 6px;
  }

  .table-list-search td{
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 10ch;
    width:auto;
  }

  .no-margin {
    margin: 0px;
  }
  .scroll-body {
    height: 500px;
    overflow-y: auto;
    display: block;
  }

  .scroll-body tr{
    width: 100%;
    display: inline-table;
    table-layout: fixed;
  }

  .headrow{
    width:auto;
  }

  .result-row{

  }

  .table-striped>tbody>tr.result-row-active>td{
    background-color: #7AC473;
    -webkit-border-radius: 0px;
    -moz-border-radius: 0px;
    border-radius: 0px
  }


</style>

<div class="container">
  <div class="row">
    <div class="col-md-12 title-col">
      <h1>ABBA Gene-Centered Search Results</h1>
      <table class="table">
        <tbody>
          <tr>
            <td>
              <strong>Curation Tiers:</strong>&nbsp;{{async_result.SelectedTierset}}<br>
              <strong>Minimum Genes:&nbsp;</strong>{{async_result.MinGenes}}<br>
              <strong>Restricted to Species:&nbsp;</strong>{{async_result.RestrictSpecies}}<br>
              <strong>Minimum Genesets:&nbsp;</strong>{{async_result.MinGenesets}}<br>
              <strong>Include Homology:&nbsp;</strong>{{async_result.IncludeHomology}}<br>
            </td>
            <td>
              <strong>User:&nbsp;</strong>VALUE<br>
              <strong>Date:&nbsp;</strong>VALUE<br>
              <br>
              <strong>Available Genes:&nbsp;</strong>{{async_result.AvailableGenes}}<br>
              <strong>Available Genesets:&nbsp;</strong>{{async_result.AvailableGenesets}}<br>
            </td>
          </tr>
        </tbody>
      </table>

      <div class="progress progress-striped">
        <div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" style="width: 100%;">
          <span>100% Complete</span>
        </div>
      </div>
    </div>

  </div><!-- end row -->

  <div class="row">
    <div class="col-md-12 title-col">
      <ul class="nav nav-tabs nav-justified" role="tablist">
        {% if async_result.GenesOfInterestCount %}
          {% set genesOfInterestCnt=async_result.GenesOfInterestCount %}
        {% else %}
          {% set genesOfInterestCnt=0 %}
        {% endif %}
        <li class="active"><a href="#GenesOfInterest" aria-controls="GenesOfInterest" role="tab" data-toggle="tab">Genes of Interest ({{genesOfInterestCnt}})</a></li>

        {% if async_result.GenesetResultsCount %}
          {% set genesetCount=async_result.GenesetResultsCount %}
        {% else %}
          {% set genesetCount=0 %}
        {% endif %}
        <li><a href="#MatchingGenesets" aria-controls="MatchingGenesets" role="tab" data-toggle="tab">Matching Genesets ({{genesetCount}})</a></li>

        {% if async_result.GeneResultsCount %}
          {% set geneCount=async_result.GeneResultsCount %}
        {% else %}
          {% set geneCount=0 %}
        {% endif %}
        <li><a href="#ResultGenes" aria-controls="ResultGenes" role="tab" data-toggle="tab">Result Genes ({{async_result.GeneResultsCount}})</a></li>
      </ul>
    </div>

    <div class="tab-content">

      <div role="tabpanel" class="tab-pane active" id="GenesOfInterest">
        <div class="col-md-4 table-col">
          <input class="form-control result-search-input" id="system-searchGOI"  data-type="GOI" name="q" placeholder="Search..." required>
          <table class="table table-striped table-list-search no-margin">
            <thead>
              <tr>
                <th row-type="GOI" class="headrow">Gene<br></th>
                <th row-type="GOI" class="headrow">Species<br></th>
              </tr>
            </thead>
          </table>
          <table class="table table-striped table-list-search scroll-body">

        {% if async_result.GenesOfInterest %}
        <tbody class="scroll-tbody" id="GenesOfInterestTableBody">
            {% for gene in async_result.GenesOfInterest %}
            <tr class="result-row" row-type="GOI">

              <td>{{gene[1]}}<br></td>
              <td>{{gene[2]}}<br></td>

            </tr>
            {% endfor %}
          </tbody>
          {% endif %}
          </table>
        </div>
        <div data-type="InfoPane" class="col-md-8">
          <h2 class="extra-info-header"></h2>
        </div>
      </div>

      <div role="tabpanel" class="tab-pane" id="MatchingGenesets">
        <div class="col-md-4 table-col">
          <input class="form-control result-search-input" id="system-searchMG"  data-type="MG" name="q" placeholder="Search..." required>
          <table class="table table-striped table-list-search no-margin">
            <thead>
              <tr>
                <th row-type="MG" class="headrow">Geneset<br></th>
                <th row-type="MG" class="headrow">Matches<br></th>
              </tr>
            </thead>
          </table>
          <table class="table table-striped table-list-search scroll-body">
            {% if async_result.GenesetResults %}
            <tbody class="scroll-tbody" id="MatchingGenesetsTableBody">
              {% for geneset in async_result.GenesetResults %}
              <tr class="result-row" row-type="MG">
                <td>{{geneset[1]}}<br></td>
                <td>{{geneset[2]}}</td>
              </tr>
              {% endfor %}
            </tbody>
            {% endif %}
          </table>
        </div>
        <div data-type="InfoPane" class="col-md-8">
          <h2 class="extra-info-header"></h2>
        </div>
      </div>

      <div role="tabpanel" class="tab-pane" id="ResultGenes">
        <div class="col-md-4 table-col">
          <input class="form-control result-search-input" id="system-searchRG" data-type="RG" name="q" placeholder="Search..." required>
          <table class="table table-striped table-list-search no-margin">
            <thead>
              <tr>
                <th row-type="RG" class="headrow">Gene<br></th>
                <th row-type="RG" class="headrow">Species<br></th>
                <th row-type="RG" class="headrow">Genesets<br></th>
              </tr>
            </thead>
          </table>
          <table class="table table-striped table-list-search scroll-body">
            {% if async_result.GeneResults %}
            <tbody  class="scroll-tbody" id="ResultGenesTableBody">
              {% for gene in async_result.GeneResults %}
              <tr class="result-row" row-type="RG">
                <td>{{gene[1]}}<br></td>
                <td>{{gene[2]}}<br></td>
                <td>{{gene[3]}}</td>
              </tr>
              {% endfor %}
            </tbody>
            {% endif %}
          </table>
        </div>
        <div data-type="InfoPane" class="col-md-8">
          <h2 class="extra-info-header"></h2>
        </div>
      </div>

    </div>

  </div><!-- end row-->

</div><!-- end container -->


<script type="text/javascript">
$(document).ready(function() {


  var activeSystemClass = $('.list-group-item.active');

  var LightTableSorter = (function(Arr) {

    var _th, _cellIndex, _order = '';

    function _text(row) {
      return row.cells.item(_cellIndex).textContent.toLowerCase();
    }

    function _sort(a, b) {
      var va = _text(a), vb = _text(b), n = parseInt(va, 10);
      if (n) {
        va = n;
        vb = parseInt(vb, 10);
      }
      return va > vb ? 1 : va < vb ? -1 : 0;
    }

    function _toggle() {
      var c = _order !== 'asc' ? 'asc' : 'desc';
      _th.className = (_th.className.replace(_order, '') + ' ' + c).trim();
      _order = c;
    }

    function _reset() {
      _th.className = _th.className.replace('asc', '').replace('desc', '');
      _order = '';
    }

    function onClickEvent(e) {
      var bodyID;
      var workingTab = e.target.getAttribute("row-type");
      console.log(workingTab);

      if(workingTab == "GOI"){
        bodyID = '#GenesOfInterestTableBody';
      }else if(workingTab == "MG"){
        bodyID = '#MatchingGenesetsTableBody';
      }else if(workingTab == "RG"){
        bodyID = '#ResultGenesTableBody';
      }

      if(_th && _th !== e.target){
        _reset();
      }
      _th = e.target;
      _cellIndex = _th.cellIndex;
      var tbody = $(bodyID)[0];
      var rows = tbody.rows;
      var intialRowCount = rows.length;
      for(var r=0; r<intialRowCount; r++){
        if(!rows.item(r).hasAttribute("row-type")){
          rows.item(r).remove();
        }
      }

      if (rows) {
        rows = Arr.sort.call(Arr.slice.call(rows, 0), _sort);
        if (_order === 'asc') {
          Arr.reverse.call(rows);
        }
        _toggle();
        tbody.innerHtml = '';
        Arr.forEach.call(rows, function(row) { tbody.appendChild(row); });
      }
    }

    return {
      init: function() {
        var ths = $('.headrow')//document.getElementsByTagName('th');
        Arr.forEach.call(ths, function(th) { th.onclick = onClickEvent; });
      }
    };
  })(Array.prototype);
  LightTableSorter.init();

  //Change active result
  $('.result-row').click(function() {
    $('.result-row-active').switchClass('result-row-active', 'result-row');
    $(this).switchClass('result-row', 'result-row-active');
    updateInfoPane($(this));
  });

  function updateInfoPane(activeRow){
    var parentTab = activeRow.parent().closest('.tab-pane');
    var infoPane = parentTab.children('div').last();
    var headerText = activeRow.children('td').first().text();
    infoPane.children('h2').closest('.extra-info-header').text(headerText);
  }

  $('#system-searchGOI').keyup( function(e){
    search_tab("GOI");
  });
  $('#system-searchMG').keyup( function(e){
    search_tab("MG");
  });
  $('#system-searchRG').keyup( function(e){
    search_tab("RG");
  });


  function search_tab(workingTab) {
     var workingTab;// = that.getAttribute("data-type");

     var that;
     var tableBody;
     var tableRowsClass;

     if(workingTab == "GOI"){
       that = $('#system-searchGOI');
       tableBody = $('#GenesOfInterestTableBody');
       tableRowsClass = $('#GenesOfInterestTableBody tr');
     }else if(workingTab == "MG"){
       that = $('#system-searchMG');
       tableBody = $('#MatchingGenesetsTableBody');
       tableRowsClass = $('#MatchingGenesetsTableBody tr');
     }else if(workingTab == "RG"){
       that = $('#system-searchRG');
       tableBody = $('#ResultGenesTableBody');
       tableRowsClass = $('#ResultGenesTableBody tr');
     }

      $('.search-sf').remove();
      tableRowsClass.each( function(i, val) {

          //Lower text for case insensitive
          var rowText = $(val).text().toLowerCase();
          var inputText = $(that).val().toLowerCase();
          if(inputText != '')
          {
              $('.search-query-sf').remove();
              tableBody.prepend('<tr class="search-query-sf"><td colspan="6"><strong>Searching for: "'
                  + $(that).val()
                  + '"</strong></td></tr>');
          }
          else
          {
              $('.search-query-sf').remove();
          }

          if( rowText.indexOf( inputText ) == -1 )
          {
              //hide rows
              tableRowsClass.eq(i).hide();

          }
          else
          {
              $('.search-sf').remove();
              tableRowsClass.eq(i).show();
          }
      });
      //all tr elements are hidden
      if(tableRowsClass.children(':visible').length == 0)
      {
          tableBody.append('<tr class="search-sf"><td class="text-muted" colspan="6">No entries found.</td></tr>');
      }

      LightTableSorter.init();
  };

});
</script><!-- end table filter script-->

<script>
    (function ($) {
    var
    defaults = {
        className: 'autosizejs',
        id: 'autosizejs',
        append: '\n',
        callback: false,
        resizeDelay: 10,
        placeholder: true
    },

    // border:0 is unnecessary, but avoids a bug in Firefox on OSX
    copy = '<textarea tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;"/>',

    // line-height is conditionally included because IE7/IE8/old Opera do not return the correct value.
    typographyStyles = [
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent',
        'whiteSpace'
    ],

    // to keep track which textarea is being mirrored when adjust() is called.
    mirrored,

    // the mirror element, which is used to calculate what size the mirrored element should be.
    mirror = $(copy).data('autosize', true)[0];

    // test that line-height can be accurately copied.
    mirror.style.lineHeight = '99px';
    if ($(mirror).css('lineHeight') === '99px') {
        typographyStyles.push('lineHeight');
    }
    mirror.style.lineHeight = '';

    $.fn.autosize = function (options) {
        if (!this.length) {
            return this;
        }

        options = $.extend({}, defaults, options || {});

        if (mirror.parentNode !== document.body) {
            $(document.body).append(mirror);
        }

        return this.each(function () {
            var
            ta = this,
            $ta = $(ta),
            maxHeight,
            minHeight,
            boxOffset = 0,
            callback = $.isFunction(options.callback),
            originalStyles = {
                height: ta.style.height,
                overflow: ta.style.overflow,
                overflowY: ta.style.overflowY,
                wordWrap: ta.style.wordWrap,
                resize: ta.style.resize
            },
            timeout,
            width = $ta.width(),
            taResize = $ta.css('resize');

            if ($ta.data('autosize')) {
                // exit if autosize has already been applied, or if the textarea is the mirror element.
                return;
            }
            $ta.data('autosize', true);

            if ($ta.css('box-sizing') === 'border-box' || $ta.css('-moz-box-sizing') === 'border-box' || $ta.css('-webkit-box-sizing') === 'border-box'){
                boxOffset = $ta.outerHeight() - $ta.height();
            }

            // IE8 and lower return 'auto', which parses to NaN, if no min-height is set.
            minHeight = Math.max(parseFloat($ta.css('minHeight')) - boxOffset || 0, $ta.height());

            $ta.css({
                overflow: 'hidden',
                overflowY: 'hidden',
                wordWrap: 'break-word' // horizontal overflow is hidden, so break-word is necessary for handling words longer than the textarea width
            });

            if (taResize === 'vertical') {
                $ta.css('resize','none');
            } else if (taResize === 'both') {
                $ta.css('resize', 'horizontal');
            }

            // The mirror width must exactly match the textarea width, so using getBoundingClientRect because it doesn't round the sub-pixel value.
            // window.getComputedStyle, getBoundingClientRect returning a width are unsupported, but also unneeded in IE8 and lower.
            function setWidth() {
                var width;
                var style = window.getComputedStyle ? window.getComputedStyle(ta, null) : false;

                if (style) {

                    width = ta.getBoundingClientRect().width;

                    if (width === 0 || typeof width !== 'number') {
                        width = parseFloat(style.width);
                    }

                    $.each(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(i,val){
                        width -= parseFloat(style[val]);
                    });
                } else {
                    width = $ta.width();
                }

                mirror.style.width = Math.max(width,0) + 'px';
            }

            function initMirror() {
                var styles = {};

                mirrored = ta;
                mirror.className = options.className;
                mirror.id = options.id;
                maxHeight = parseFloat($ta.css('maxHeight'));

                // mirror is a duplicate textarea located off-screen that
                // is automatically updated to contain the same text as the
                // original textarea.  mirror always has a height of 0.
                // This gives a cross-browser supported way getting the actual
                // height of the text, through the scrollTop property.
                $.each(typographyStyles, function(i,val){
                    styles[val] = $ta.css(val);
                });

                $(mirror).css(styles).attr('wrap', $ta.attr('wrap'));

                setWidth();

                // Chrome-specific fix:
                // When the textarea y-overflow is hidden, Chrome doesn't reflow the text to account for the space
                // made available by removing the scrollbar. This workaround triggers the reflow for Chrome.
                if (window.chrome) {
                    var width = ta.style.width;
                    ta.style.width = '0px';
                    var ignore = ta.offsetWidth;
                    ta.style.width = width;
                }
            }

            // Using mainly bare JS in this function because it is going
            // to fire very often while typing, and needs to very efficient.
            function adjust() {
                var height, original;

                if (mirrored !== ta) {
                    initMirror();
                } else {
                    setWidth();
                }

                if (!ta.value && options.placeholder) {
                    // If the textarea is empty, copy the placeholder text into
                    // the mirror control and use that for sizing so that we
                    // don't end up with placeholder getting trimmed.
                    mirror.value = ($ta.attr("placeholder") || '');
                } else {
                    mirror.value = ta.value;
                }

                mirror.value += options.append || '';
                mirror.style.overflowY = ta.style.overflowY;
                original = parseFloat(ta.style.height);

                // Setting scrollTop to zero is needed in IE8 and lower for the next step to be accurately applied
                mirror.scrollTop = 0;

                mirror.scrollTop = 9e4;

                // Using scrollTop rather than scrollHeight because scrollHeight is non-standard and includes padding.
                height = mirror.scrollTop;

                if (maxHeight && height > maxHeight) {
                    ta.style.overflowY = 'scroll';
                    height = maxHeight;
                } else {
                    ta.style.overflowY = 'hidden';
                    if (height < minHeight) {
                        height = minHeight;
                    }
                }

                height += boxOffset;

                if (original !== height) {
                    ta.style.height = height + 'px';

                    // Trigger a repaint for IE8 for when ta is nested 2 or more levels inside an inline-block
                    mirror.className = mirror.className;

                    if (callback) {
                        options.callback.call(ta,ta);
                    }
                    $ta.trigger('autosize.resized');
                }
            }

            function resize () {
                clearTimeout(timeout);
                timeout = setTimeout(function(){
                    var newWidth = $ta.width();

                    if (newWidth !== width) {
                        width = newWidth;
                        adjust();
                    }
                }, parseInt(options.resizeDelay,10));
            }

            if ('onpropertychange' in ta) {
                if ('oninput' in ta) {
                    // Detects IE9.  IE9 does not fire onpropertychange or oninput for deletions,
                    // so binding to onkeyup to catch most of those occasions.  There is no way that I
                    // know of to detect something like 'cut' in IE9.
                    $ta.on('input.autosize keyup.autosize', adjust);
                } else {
                    // IE7 / IE8
                    $ta.on('propertychange.autosize', function(){
                        if(event.propertyName === 'value'){
                            adjust();
                        }
                    });
                }
            } else {
                // Modern Browsers
                $ta.on('input.autosize', adjust);
            }

            // Set options.resizeDelay to false if using fixed-width textarea elements.
            // Uses a timeout and width check to reduce the amount of times adjust needs to be called after window resize.

            if (options.resizeDelay !== false) {
                $(window).on('resize.autosize', resize);
            }

            // Event for manual triggering if needed.
            // Should only be needed when the value of the textarea is changed through JavaScript rather than user input.
            $ta.on('autosize.resize', adjust);

            // Event for manual triggering that also forces the styles to update as well.
            // Should only be needed if one of typography styles of the textarea change, and the textarea is already the target of the adjust method.
            $ta.on('autosize.resizeIncludeStyle', function() {
                mirrored = null;
                adjust();
            });

            $ta.on('autosize.destroy', function(){
                mirrored = null;
                clearTimeout(timeout);
                $(window).off('resize', resize);
                $ta
                    .off('autosize')
                    .off('.autosize')
                    .css(originalStyles)
                    .removeData('autosize');
            });

            // Call adjust in case the textarea already contains text.
            adjust();
        });
    };
    }(jQuery || $)); // jQuery or jQuery-like library, such as Zepto


    $(document).ready(function(){
        $('textarea').autosize();
    });
</script>

<script type="text/javascript">
makeInnerList();
function makeInnerList() {
	var a = {{async_result.GeneResultCount}};
	var stuffString = "{{async_result}}";
	stuffString = stuffString.replace(/&#39;/ig,'\"');
	var stuffString2 = '\''+stuffString+'\'';
	stuffString2 = stuffString2.replace(/u"/ig, '\"');
	stuffString2 = stuffString2.replace(/'/ig, '');
	modifiableData = JSON.parse(stuffString2);
};

function removeGene(ogid) {
	delete modifiableData.GeneResults[ogid];
	var blah = modifiableData;
};

function toggle(id) {
 if( document.getElementById(id).style.display=='none' ){
   document.getElementById(id).style.display = '';
 }else{
   document.getElementById(id).style.display = 'none';
 }
}

function returnGSName(gsid){
	document.getElementById(gsid).innerHTML = modifiableData.GSResults[gsid].gs_name;
}

function newGeneset(){
	var genes = [];
	$('input:checkbox[name="g_id[]"]').each(function() {
	if (this.checked) {
	    genes.push(this.value);
	}
	});
	window.location.href = "/uploadgenesetpre/"+genes.join("_")+".html";
}
</script>
{% include 'footer.html' %}
